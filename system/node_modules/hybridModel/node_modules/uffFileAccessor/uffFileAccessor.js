
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	fs = require('fs');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;


	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'queryInfo',
				optional: false
			},
			{
				name: 'clientProfile',
				optional: false
			},
			{
				name: 'validUriSegmentNames',
				optional: false
			}
		]
	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	//LOCAL FUNCTIONS ====================================

	var getList = function(path, callback) {
		fs.readdir(path, callback);
	}

	var getFile = function(path, callback) {
		fs.readFile(path, callback);
	}

	var removeDottedDirs = function(list) {
		var outArray = [];
		for (var i = 0, len = list.length; i < len; i++) {
			var element = list[i];
			if (element.substring(0, 1) == '.') {
				continue;
			}
			outArray.push(element);
		}
		return outArray;
	}

	var digestQuery = function(query, path, newQuery) {
		path = path ? path : '';
		newQuery = newQuery ? newQuery : '';

		var current = query.shift(),
			newPath;

		newPath = path + (current.value == 'list' ? '' : '/' + current.value);
		newQuery = newQuery + '/' + current.name + (current.value == 'list' ? '' : '/' + current.value);
qtools.dump({'\n\n===== self.clientProfile.dataAccess =====\n':self.clientProfile.dataAccess});
self.clientProfile.dataAccess.isAllowed(current.name, current.value);
		if (qtools.isEmpty(query)) {
			//this is the last element
			var outObj = {
				path: newPath,
				type: current.value == 'list' ? 'list' : 'data',
				queryPath: newQuery,
				finalDataName: current.name
			};
			return outObj;
		} else {
			newQuery = newQuery.replace(/^\//, '');
			return digestQuery(query, newPath, newQuery);
		}

	}

	var removeUnauthorizedDirs = function(result, dataName) {
		var allowed = self.clientProfile.dataAccess.allowed[dataName],
			disallowed = self.clientProfile.dataAccess.disallowed[dataName];

		var outList = [];

		for (var i = 0, len = result.length; i < len; i++) {
			var element = result[i];

			//if any items are allowed, then this one must be listed
			//if any items are disallowed, then this one must not be listed.
			if ((typeof (allowed) == 'undefined' || (typeof (allowed) != 'undefined' && allowed.indexOf(element) > -1)) &&
				(typeof (disallowed) == 'undefined' || (typeof (disallowed) != 'undefined' && disallowed.indexOf(element) < 0))) {
				outList.push(element);
			}
		}
		return outList;
	}

	//METHODS AND PROPERTIES ====================================




	this.addUriList = function(rawData, queryPath) {
		var outList = [];
		for (var i = 0, len = rawData.length; i < len; i++) {
			var element = rawData[i].replace(/\..*$/, ''),
				uri = global.localEnvironment.baseUri + queryPath + '/' + element,
				workingItem = {
					id: element
				};
			outList.push({
				data: workingItem,
				uri: uri
			});
		}
		return outList;
	}

	this.goGetIt = function() {
		var basePath = args.clientProfile.dataSource.location,
			queryInfo = args.queryInfo,
			rawResult;

		var lookupControl = digestQuery(queryInfo, '');
		qtools.addMetaData('lookupControl', lookupControl);

		var dirCallback = function(err, result) {
			if (err) {
				self.emit('gotBadData', err);
			} else {
				result = removeDottedDirs(result);

				result = removeUnauthorizedDirs(result, lookupControl.finalDataName);

				var outList = self.addUriList(result, lookupControl.queryPath);

				self.emit('gotRawData', outList);
			}
		}

		var fileCallback = function(err, result) {

			if (err) {
				self.emit('gotBadData', err);
			} else {
				result = result
				.toString("utf8", 0, result.length)
				.replace(/(\r\n)|(\n\r)|(\r)/g, "\n");

				var processedResult = result.split("\n"),
					finalDataList = [];

				for (var i = 0, len = processedResult.length; i < len; i++) {
					var element = processedResult[i],
						rowArray = element.split("\t");

					if (element.length) {
						//don't want empty rows
						finalDataList.push(rowArray);
					}
				}
				self.emit('gotRawData', finalDataList);
			}
		}

		var path = basePath + lookupControl.path;

		var extensionList = ['txt'],
			attemptedPathList = []; //made available for debugging
		var fsStatsCallback = function(err, fsResult) {
			//closure: path, extensions, attemptedPathList

			attemptedPathList.push(path); //for the error message

			if (err) {
				var extension = extensionList.pop();
				if (extension) {
					path = path + '.' + extension;
					fs.stat(path, fsStatsCallback);
				} else {
					self.emit('gotBadData', qtools.extend(err, {
						attemptedPathList: attemptedPathList
					}));
				}
				return;
			}

			qtools.addMetaData('finalPath', path);

			if (fsResult.isDirectory()) {
				if (lookupControl.type == 'data') {
					path = basePath + lookupControl.path + '/_entityData.txt';
					extensionList = [];
					fs.stat(path, fsStatsCallback);
				} else {
					getList(path, dirCallback);
				}
			} else {

				getFile(path, fileCallback);
			}

		}

		fs.stat(path, fsStatsCallback);

	}

	//INITIALIZATION ====================================

	this.getRawData = function(callback) {

		self.on('gotRawData', function(finalDataList) {

			callback({
				status: 1,
				data: finalDataList,
				meta: qtools.getMetaData()
			});
		});

		self.on('gotBadData', function(err) {

			callback({
				status: -1,
				data: err,
				meta: qtools.getMetaData()
			});
		});

		
			self.goGetIt();
	};

	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;








