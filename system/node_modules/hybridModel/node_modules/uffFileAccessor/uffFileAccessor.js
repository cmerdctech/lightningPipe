
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	fs = require('fs');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;


	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'queryInfo',
				optional: false
			},
			{
				name: 'clientProfile',
				optional: false
			},
			{
				name: 'removeUnauthorizedElements',
				optional: false
			},
			{
				name: 'dataConverter',
				optional: false
			}
		]
	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	//LOCAL FUNCTIONS ====================================

	var getList = function(path, callback) {
		fs.readdir(path, callback);
	}

	var getFile = function(path, callback) {
		fs.readFile(path, callback);
	}

	var removeDottedDirs = function(list) {
		var outArray = [];
		for (var i = 0, len = list.length; i < len; i++) {
			var element = list[i];
			if (element.substring(0, 1) == '.') {
				continue;
			}
			outArray.push(element);
		}
		return outArray;
	}

	var digestQuery = function(query, path, newQuery, status) {
		path = path ? path : '';
		newQuery = newQuery ? newQuery : '';

		var current = query.shift(),
			newPath,
			isAllowed = self.clientProfile.dataAccess.isAllowed(current.name, current.value),
			status = status ? status : {},
			badStatus = {};

		if (!isAllowed) {
			badStatus = {
				errno: -1,
				message: "Not allowed to access " + current.name + "=" + current.value
			};
		}
		newPath = path + (current.value == 'list' ? '' : '/' + current.value);
		newQuery = newQuery + '/' + current.name + (current.value == 'list' ? '' : '/' + current.value);

		if (qtools.isEmpty(query)) {
			//this is the last element
			var status = qtools.extend(status, badStatus);
			var outObj = {
				path: newPath,
				type: current.value == 'list' ? 'list' : 'data',
				queryPath: newQuery,
				finalDataName: current.name,
				finalValue:current.value,
				status: status
			};
			return outObj;
		} else {
			newQuery = newQuery.replace(/^\//, '');
			return digestQuery(query, newPath, newQuery, qtools.extend(status, badStatus));
		}

	}

	//METHODS AND PROPERTIES ====================================




	this.addUriList = function(rawData, queryPath) {
		var outList = [];
		for (var i = 0, len = rawData.length; i < len; i++) {
			var element = rawData[i].replace(/\..*$/, ''),
				uri = global.localEnvironment.baseUri + queryPath + '/' + element,
				workingItem = {
					id: element
				};
			outList.push({
				data: workingItem,
				uri: uri
			});
		}
		return outList;
	}

	this.goGetIt = function() {
		var basePath = args.clientProfile.dataSource.location,
			queryInfo = args.queryInfo,
			rawResult;

		var lookupControl = digestQuery(queryInfo, '');

		if (lookupControl.Status == -1) {

			self.emit('gotBadData', lookupControl.status);
			return;

		}
		qtools.addMetaData('lookupControl', lookupControl);

		var dirCallback = function(err, result) {
			if (err) {
				self.emit('gotBadData', err);
			} else {
				result = removeDottedDirs(result);

				result = self.removeUnauthorizedElements(result, lookupControl.finalDataName);

				var outList = self.addUriList(result, lookupControl.queryPath);

				self.emit('gotRawData', outList);
			}
		}

		var fileCallback = function(err, result) {

			if (err) {
				self.emit('gotBadData', err);
			} else {
				result = result
				.toString("utf8", 0, result.length)
				.replace(/(\r\n)|(\n\r)|(\r)/g, "\n");

				var processedResult = result.split("\n"),
					finalDataList = [];

				for (var i = 0, len = processedResult.length; i < len; i++) {
					var element = processedResult[i],
						rowArray = element.split("\t");

					if (element.length) {
						//don't want empty rows
						finalDataList.push(rowArray);
					}
				}

				var finishedOutputObject = self.dataConverter.convert(finalDataList, lookupControl.finalValue);
				self.emit('gotRawData', finishedOutputObject);
			}
		}

		var path = basePath + lookupControl.path;

		var extensionList = [self.clientProfile.dataSource.fileExtension],
			attemptedPathList = []; //made available for debugging
		var fsStatsCallback = function(err, fsResult) {
			//closure: path, extensions, attemptedPathList

			attemptedPathList.push(path); //for the error message

			if (err) {
				var extension = extensionList.pop();
				if (extension) {
					path = path + '.' + extension;
					fs.stat(path, fsStatsCallback);
				} else {
					self.emit('gotBadData', qtools.extend(err, {
						attemptedPathList: attemptedPathList
					}));
				}
				return;
			}

			qtools.addMetaData('finalPath', path);

			if (fsResult.isDirectory()) {
				if (lookupControl.type == 'data') {
					path = basePath + lookupControl.path + '/_entityData.' + self.clientProfile.dataSource.fileExtension;
					extensionList = [];
					fs.stat(path, fsStatsCallback);
				} else {
					getList(path, dirCallback);
				}
			} else {

				getFile(path, fileCallback);
			}

		}

		fs.stat(path, fsStatsCallback);

	}

	//INITIALIZATION ====================================

	this.getRawData = function(callback) {

		self.on('gotRawData', function(finalDataList) {

			callback({
				status: 1,
				data: finalDataList,
				meta: qtools.getMetaData()
			});
		});

		self.on('gotBadData', function(err) {

			callback({
				status: -1,
				data: err,
				meta: qtools.getMetaData()
			});
		});


		self.goGetIt();
	};

	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;










