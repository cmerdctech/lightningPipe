'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.metaData = {};
	this.addMeta = function(name, data) {
		this.metaData[name] = data;
	}




	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'queryInfo',
				optional: false
			},
			{
				name: 'clientProfile',
				optional: false
			},
			{
				name: 'removeUnauthorizedElements',
				optional: false
			},
			{
				name: 'dataConverter',
				optional: false
			}
		]
	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	var dataConverter = this.dataConverter;


	//LOCAL FUNCTIONS ====================================

	var callbacksDone = function() {

		for (var i in self.callbackList) {
			var element = self.callbackList[i];
			if (element === '') {
				return false;
			}
		}
		return true;
	}

	var generateCallback = function(id) {

		if (typeof (self.callbackList) == 'undefined') {
			self.callbackList = {};
		}

		self.callbackList[id] = '';
		return function(result) { //CALLBACK FROM ACCESSOR ============================
			var myId = id;

			if (result.type == 'list') {
				result.data = self.removeUnauthorizedElements(result.data, lookupControl.finalDataName);
				result.data = addUriList(result.data, lookupControl.queryPath);
			}

			self.callbackList[myId] = result.data;

			if (callbacksDone()) {



				
var assembler=self.dataConverter.dictionary.getAssembler(self.primarySchema)

var outObj=assembler.execute(self.callbackList);
				var outputTmp = {
					status: 1,
					data: outObj
				}
				self.parentCallback(outputTmp);
			}

		}
	}



	var digestQuery = function(query, path, newQuery, status) {
		path = path ? path : '';
		newQuery = newQuery ? newQuery : '';
		
		/*
			Note: This query string analysis should be moved to, probably, server.js.
			It got here because this is where it is used. Still, this thing should not
			be aware of the input to the system. I'll change it someday. 
			Sorry, tqii
		*/

		var current = query.shift(),
			newPath,
			isAllowed = self.clientProfile.dataAccess.isAllowed(current.name, current.value),
			status = status ? status : {},
			badStatus = {};

		if (!isAllowed) {
			badStatus = {
				status: -1,
				data: {
					errno: -1,
					message: "Not allowed to access " + current.name + "=" + current.value
				}
			};
			self.badStatus = badStatus;
		}

		if (qtools.isEmpty(query)) {
			//this is the last element
			var status = qtools.extend(status, badStatus),
				fileName;


			newQuery = newQuery + '/' + current.name + (current.value == 'list' ? '' : '/' + current.value);

			newQuery = newQuery.replace(/^\//, '');
			var outObjTemplate = {
				dataLocation: '',
				type: current.value == 'list' ? 'list' : 'data',
				queryPath: newQuery,
				finalDataName: current.name,
				finalValue: current.value,
				status: status
			};

			var outObj = outObjTemplate;

			self.dataConverter.dictionary.setMainDefinitionName(current.value); //and when I move the query parsing to the top, this woud move, too
			var componentSchemaInfo = self.dataConverter.dictionary.getComponentSchemaInfo(current.value),
				fileName = self.dataConverter.dictionary.getFileName(current.value);
				
			if (current.value == 'list') {
				var fileName = current.value;
				newPath = path + (current.value == 'list' ? '' : '/' + fileName);
				outObj.dataLocation = newPath;

			} else if (componentSchemaInfo) {
				self.primarySchema=current.value;
				var outList = [];
				var list = componentSchemaInfo.componentList;

				for (var i = 0, len = list.length; i < len; i++) {
					var workingObj = qtools.clone(outObjTemplate),
						element = list[i],
						fileNameSegment = self.dataConverter.dictionary.getFileName(element);

					workingObj.dataLocation = path + (current.value == 'list' ? '' : '/' + fileNameSegment);
					workingObj.finalValue = element;

					outList.push(workingObj);

				}

				return outList;

			} else {
				fileName = fileName;
				newPath = path + (current.value == 'list' ? '' : '/' + fileName);
				outObj.dataLocation = newPath;

			}



			return [outObj];
		} else {
			newPath = path + (current.value == 'list' ? '' : '/' + current.value);
			newQuery = newQuery + '/' + current.name + (current.value == 'list' ? '' : '/' + current.value);
			newQuery = newQuery.replace(/^\//, '');
			return digestQuery(query, newPath, newQuery, qtools.extend(status, badStatus));
		}

	}


	var addUriList = function(rawData, queryPath) {
		var outList = [];
		for (var i = 0, len = rawData.length; i < len; i++) {
			var element = rawData[i].replace(/\..*$/, ''),
				schemaName = self.dataConverter.dictionary.getSchemaName(element),
				uri = global.localEnvironment.baseUri + queryPath + '/' + (schemaName ? schemaName : element),
				workingItem = {
					id: element
				};

			;

			outList.push({
				data: workingItem,
				uri: uri
			});
		}
		return outList;
	}

	//METHODS AND PROPERTIES ====================================



	//INITIALIZATION ====================================

	this.dataComponentGenerator = require(self.clientProfile.dataSource.api.fileAccessorName);

	var lookupControlList = digestQuery(this.queryInfo, '');
	
	this.dataComponentList = [];
	for (var i = 0, len = lookupControlList.length; i < len; i++) {
		var lookupControl = lookupControlList[i];


		this.dataComponentList.push({
			schema: lookupControl.finalValue,
			dataComponent:
			this.dataComponent = new this.dataComponentGenerator({
				clientProfile: self.clientProfile,
				dataConverter: self.dataConverter,
				lookupControl: lookupControl
			})
		});
	}


	this.executeQuery = function(callback) {
		if (typeof (self.badStatus) != 'undefined') {
			callback(self.badStatus);
			return;
		}
		self.parentCallback = callback;


		var list = this.dataComponentList;
		for (var i = 0, len = list.length; i < len; i++) {
			var element = list[i];

			element.dataComponent.getRawData(generateCallback(element.schema));
		}

	}

	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;





