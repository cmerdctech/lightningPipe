'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.metaData = {};
	this.addMeta = function(name, data) {
		this.metaData[name] = data;
	}

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'tables',
				optional: true
			}
		]
	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	//LOCAL FUNCTIONS ====================================



	//METHODS AND PROPERTIES ====================================
	this.indexes = {};
	this.workingTable = [];
	this.baseTableName = '';
	this.duplicates = {};

	this.removeDupes = function(tableName) {
		var outList = [],
			uniqueTokenList = {};
		for (var i = 0, len = this.tables[tableName].length; i < len; i++) {
			var element = this.tables[tableName][i],

				uniqueToken = qtools.hash(element);

			if (!uniqueTokenList[uniqueToken]) {
				uniqueTokenList[uniqueToken] = true;
				outList.push(element);
			} else {
				if (!this.duplicates[tableName]) {
					this.duplicates[tableName] = [];
				}
				this.duplicates[tableName].push(element);
			}

		}

		this.tables[tableName] = outList;
	}

	this.setBaseTable = function(tableName) {
		this.baseTableName = tableName;


		if (global.localEnvironment.testServer && !this.tables[tableName]) {
			qtools.message("SQLizer Invalid tableName: " + tableName + " does not exist");
		}
		if (global.localEnvironment.testServer) {
			qtools.message("SQLizer Base Table " + tableName + " has " + this.tables[tableName].length + " records");
		}

		for (var i = 0, len = this.tables[tableName].length; i < len; i++) {
			var element = this.tables[tableName][i];

			var recordObject = {};
			recordObject[tableName] = element;
			this.workingTable.push(recordObject);
		}
	}

	this.index = function(tableName, propertyName) {
		var newIndex = {},
			table = this.tables[tableName];

		for (var i = 0, len = table.length; i < len; i++) {
			var element = table[i];

			if (typeof (newIndex[element[propertyName]]) == 'undefined') {
				newIndex[element[propertyName]] = [];
			}

			newIndex[element[propertyName]].push(element);
			if (newIndex[element[propertyName]].length > 1) {

			}
		}

		if (typeof (this.indexes[tableName]) == 'undefined') {
			this.indexes[tableName] = {};
		}

		this.indexes[tableName][propertyName] = newIndex;

	}



	this.badJoin = function(linkColumn, targetTableName, targetLinkColumn) {
		var index = this.indexes[targetTableName][targetLinkColumn],
			resultTable = [];

		for (var i = 0, len = this.workingTable.length; i < len; i++) {
			var element = this.workingTable[i][this.baseTableName][linkColumn];

			this.workingTable[i][targetTableName] = index[element];

			if (typeof (index[element]) == 'undefined') {
				continue;
			}
			for (var j = 0, len2 = index[element].length; j < len2; j++) {
				var matchingRecords = index[element],
					newRecord = {};
				newRecord = qtools.clone(this.workingTable[i]);
				newRecord[targetTableName] = index[element][j]
				resultTable.push(newRecord);
			}

		}

		this.workingTable = resultTable;
	}



	this.leftJoin = function(linkColumn, targetTableName, targetLinkColumn) {

		if (!self.indexes[targetTableName] || !self.indexes[targetTableName][targetLinkColumn]) {
			self.index(targetTableName, targetLinkColumn);
		}

		self.index(this.baseTableName, targetLinkColumn);

		var index = this.indexes[targetTableName][targetLinkColumn],
			resultTable = [];

		for (var i = 0, len = this.workingTable.length; i < len; i++) {

			var element = this.workingTable[i][this.baseTableName][linkColumn];


			this.workingTable[i][targetTableName] = index[element];

			if (typeof (index[element]) == 'undefined') {
				var newRecord = {};
				newRecord = this.workingTable[i];
				newRecord[targetTableName] = {};
				resultTable.push(newRecord)
			} else {
				for (var j = 0, len2 = index[element].length; j < len2; j++) {
					var matchingRecords = index[element],
						newRecord = {};
					newRecord = this.workingTable[i];
					newRecord[targetTableName] = index[element][j];
					resultTable.push(newRecord);
				}
			}



		}

		this.workingTable = resultTable;
	}

	this.badInnerJoin = function(linkColumn, targetTableName, targetLinkColumn) {

		if (!self.indexes[targetTableName] || !self.indexes[targetTableName][targetLinkColumn]) {
			self.index(targetTableName, targetLinkColumn);
		}

		var index = this.indexes[targetTableName][targetLinkColumn],
			outList = [],
			currInx;

		for (var i = 0, len = this.workingTable.length; i < len; i++) {
			var element = this.workingTable[i][this.baseTableName][linkColumn];
			if (index[element]) {
				outList.push(this.workingTable[i]);
				currInx = outList.length - 1;
		//		outList[currInx][targetTableName] = index[element];
				
				
				
				for (var j = 0, len2 = index[element].length; j < len2; j++) {
					var matchingRecords = index[element],
						newRecord = {};
					newRecord = this.workingTable[i];
					newRecord[targetTableName] = index[element][j];
					resultTable.push(newRecord);
				}
				
				outList[currInx][targetTableName]=newRecord;
				
			}

		}

		this.workingTable = outList;

	}

	this.innerJoin = function(linkColumn, targetTableName, targetLinkColumn) {

		if (!self.indexes[targetTableName] || !self.indexes[targetTableName][targetLinkColumn]) {
			self.index(targetTableName, targetLinkColumn);
		}

		var index = this.indexes[targetTableName][targetLinkColumn],
			outList = [],
			currInx;

		for (var i = 0, len = this.workingTable.length; i < len; i++) {
			var element = this.workingTable[i][this.baseTableName][linkColumn];
			if (index[element]) {
				outList.push(this.workingTable[i]
				);
				currInx = outList.length - 1;
				outList[currInx][targetTableName] = index[element];
			}

		}

		this.workingTable = outList;

	}

	this.mapColumns = function(map) {

		for (var i = 0, len = this.workingTable.length; i < len; i++) {
			var element = this.workingTable[i];

			for (var fieldPath in map) {
				var mappingFunc = map[fieldPath],
					newValue = mappingFunc(element);

				qtools.putSurePath(element, fieldPath, newValue);


			}

		}
	}

	this.select = function(selectorFunction) {
		var outList = [];
		for (var i = 0, len = this.workingTable.length; i < len; i++) {
			var element = this.workingTable[i];
			if (selectorFunction(element)) {
				outList.push(element);
			}
		}

		this.workingTable = outList;
	}

	this.getResult = function() {
		if (global.localEnvironment.testServer) {
			qtools.message("SQLizer Result: " + this.workingTable.length + " records");
		}
		return this.workingTable;
	}

	//INITIALIZATION ====================================


	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;





