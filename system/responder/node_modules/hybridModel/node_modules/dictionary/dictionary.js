'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	fs = require("fs");

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		}





	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'dataSource',
				optional: false
			}
		]
	});


	//INITIALIZE OBJECT ====================================

	this.target = this.dataSource.receivingSchema

	var definitionName = self.dataSource.definitionName;
	var definitionFilePath = __dirname + '/dataDefinitions/' + definitionName + '.js'


	this.definitions = require(definitionFilePath);

	//BUILD RETURN OBJECT ====================================

	this.getFileName = function(schemaName) {
		var localName = self.dataSource.schemaSourceNameMapping ? self.dataSource.schemaSourceNameMapping[schemaName] : '',
			definedName = self.definitions[schemaName] ? self.definitions[schemaName].fileName : '',
			finalName = localName ? localName : definedName;
		return finalName;
	}


	this.getComponentSchemaInfo = function(schemaName) {
		var schemaList = self.definitions[schemaName] ? self.definitions[schemaName].componentSchemaList : '';

		if (schemaList) {
			return {
				schemaName: schemaName,
				componentList: schemaList
			};
		} else {
			return '';
		}
	}

	this.getAssembler = function(schemaName) {
		var targetSchema = this.dataSource.receivingSchema;
		var assemblerSpecs = self.definitions[schemaName] ? self.definitions[schemaName].assembler[targetSchema] : '';




		if (assemblerSpecs) {
			var assembler = require('assemblers/' + assemblerSpecs.name);
			assembler = new assembler(assemblerSpecs.params);
			return assembler;
		} else {
			var assembler = require('assemblers/concatenate');
			assembler = new assembler({});
			return assembler;
		}
	}

	this.getSchemaName = function(fileName) {
		fileName = fileName.replace(/\..*$/, '');

		var localName = qtools.getIndexByValue(self.dataSource.schemaSourceNameMapping, fileName),
			definedName = qtools.getIndexByValue(self.definitions, fileName, 'fileName'),
			finalName = localName ? localName : definedName;
		return finalName;



	}

	this.getDefinition = function(definitionName) {
		var outObj = {};


		var hoistedPropertyName = 'maps',
			destName = 'targetMap';
		if (typeof (self.definitions[definitionName][hoistedPropertyName]) != 'undefined' && typeof (self.definitions[definitionName][hoistedPropertyName][this.target]) != 'undefined') {
			outObj[destName] = self.definitions[definitionName][hoistedPropertyName][this.target];
		} else {
			outObj[destName] = {};
		}

		var hoistedPropertyName = 'assembler',
			destName = 'targetAssembler';
		if (typeof (self.definitions[definitionName][hoistedPropertyName]) != 'undefined' && typeof (self.definitions[definitionName][hoistedPropertyName][this.target]) != 'undefined') {

			var assemblerSpecs = self.definitions[definitionName][hoistedPropertyName][this.target],
				fileName = __dirname + '/node_modules/assemblers/' + assemblerSpecs.name + '/' + assemblerSpecs.name + '.js';
			if (fs.existsSync(fileName)) {
				var assembler = require(fileName);
			} else if (fs.existsSync(assemblerSpecs.name)) {
				var assembler = require(assemblerSpecs.name);
			} else {

				qtools.die({
					msg: "assembler module does not exist: " + assemblerSpecs.name,
					definition: self.definitions[definitionName]
				});
			}
			assembler = new assembler(assemblerSpecs.params);

			outObj[destName] = assembler;
		} else {
			outObj[destName] = {};
		}

		var hoistedPropertyName = 'translation',
			destName = 'targetTranslation';
		if (typeof (self.definitions[definitionName][hoistedPropertyName]) != 'undefined' && typeof (self.definitions[definitionName][hoistedPropertyName][this.target]) != 'undefined') {
			outObj[destName] = self.definitions[definitionName][hoistedPropertyName][this.target];
		} else {
			outObj[destName] = {};
		}


		outObj.fileDataFormat = self.definitions[definitionName].fileDataFormat;
		outObj.fieldList = qtools.clone(self.definitions[definitionName].fieldList);
		outObj.sourceFieldList = qtools.clone(self.definitions[definitionName].fieldList);

		if (self.simpleEntityWithFieldHeader) {
			outObj.fieldList = "simpleEntityWithFieldHeader"
		}
		;



		return outObj;
	}

	this.setMainDefinitionName = function(definitionName) {
		self.mainDefinitionName = definitionName;
	}

	this.flatSpecs = function() {

		if (self.definitions[self.mainDefinitionName]) {
			var fieldList = self.definitions[self.mainDefinitionName].fieldList;
			return {
				fieldList: fieldList,
				includeHeaderRow: false
			};
		} else {

			return {
				fieldList: {},
				includeHeaderRow: false
			};
		}

	}

	this.listDefinitions = function(simple) {
		//not used by app; occasionally easier to list this than search the file system
		simple = simple ? simple : false;

		var outList = [];
		for (var i in self.definitions) {
			var element = self.definitions[i];
			if (simple) {
				outList.push(i);
			} else {
				var item = {};
				item.name = i;

				if (element.componentSchemaList) {
					item.componentSchemaList = element.componentSchemaList.join(', ').replace(/, $/, '');
				}
				 				if (element.fieldList) {
				 					item.fieldList = element.fieldList.join(', ').replace(/, $/, '');
				 				}
				outList.push(item);
			}

		}
		return outList;
	}
	
	if (false){
	qtools.dump(this.listDefinitions());
	}

	this.forceEvent = forceEvent;
	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;





