'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.ping=qtools.ping;

	qtools.validateProperties({
		subject: args,
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'queryInfo',
				optional: false
			},
			{
				name: 'clientProfile',
				optional: false
			},
			{
				name: 'removeUnauthorizedElements',
				optional: false
			},
			{
				name: 'dataConverter',
				optional: false
			}
		]
	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	var dataConverter = this.dataConverter;


	//LOCAL FUNCTIONS ====================================

	var callbacksDone = function() {

		for (var i in self.callbackList) {
			var element = self.callbackList[i];
			if (element === '') {
				return false;
			}
		}
		return true;
	}


	var generateCallback = function(id) {

		if (typeof (self.callbackList) == 'undefined') {
			self.callbackList = {};
		}

		self.callbackList[id] = '';
		
		return function(result) { //CALLBACK FROM ACCESSOR ============================
			var myId = id;

			if (result.type == 'list') {
				result.data = self.removeUnauthorizedElements(result.data, lookupControl.finalDataName);
				result.data = addUriList(result.data, lookupControl.queryPath);
			}
			else{
				result.data = self.dataConverter.convert(result.data, lookupControl.finalValue);
			}

			self.callbackList[myId] = result.data;

			if (callbacksDone()) {
				var assembler = self.dataConverter.dictionary.getAssembler(self.primarySchema)

				var outObj = assembler.execute(self.callbackList);
				var outputTmp = {
					status: 1,
					data: outObj
				}
				self.parentCallback(outputTmp);
			}

		}
	}


	var addUriList = function(rawData, queryPath) {
		var outList = [];
		for (var i = 0, len = rawData.length; i < len; i++) {
			var element = rawData[i].replace(/\..*$/, ''),
				schemaName = self.dataConverter.dictionary.getSchemaName(element),
				uri = global.localEnvironment.baseUri + queryPath + '/' + (schemaName ? schemaName : element),
				workingItem = {
					id: element
				};

			;

			outList.push({
				data: workingItem,
				uri: uri
			});
		}
		return outList;
	}

	//METHODS AND PROPERTIES ====================================


	
	var digestQuery = function(query, path, newQuery, status) {
		//note: query originates in apiDefinition.parse()
		
		path = path ? path : '';
		newQuery = newQuery ? newQuery : '';
		
		//recursion alert!
		
		var current = query.shift(),
			newPath,
			isAllowed = self.clientProfile.dataAccess.isAllowed(current.name, current.value),
			status = status ? status : {},
			badStatus = {};

		if (!isAllowed) {
			badStatus = {
				status: -1,
				data: {
					errno: -1,
					message: "Not allowed to access " + current.name + "=" + current.value
				}
			};
			self.badStatus = badStatus;
		}

		if (qtools.isEmpty(query)) {
			//this is the last element
			var status = qtools.extend(status, badStatus),
				fileName;


			newQuery = newQuery + '/' + current.name + (current.value == 'list' ? '' : '/' + current.value);

			newQuery = newQuery.replace(/^\//, '');
			var outObjTemplate = {
				dataLocation: '',
				type: current.value == 'list' ? 'list' : 'data',
				queryPath: newQuery,
				finalDataName: current.name,
				finalValue: current.value,
				status: status
			};

			var outObj = outObjTemplate;

			self.dataConverter.dictionary.setMainDefinitionName(current.value); //and when I move the query parsing to the top, this woud move, too

			var componentSchemaInfo = self.dataConverter.dictionary.getComponentSchemaInfo(current.value),
				fileName = self.dataConverter.dictionary.getFileName(current.value);
				
			if (current.value == 'list') {
				var fileName = current.value;
				newPath = path + (current.value == 'list' ? '' : '/' + fileName);
				outObj.dataLocation = newPath;

			} else if (componentSchemaInfo) {
				self.primarySchema=current.value;
				var outList = [];
				var list = componentSchemaInfo.componentList;

				for (var i = 0, len = list.length; i < len; i++) {
					var workingObj = qtools.clone(outObjTemplate),
						element = list[i],
						fileNameSegment = self.dataConverter.dictionary.getFileName(element);

					workingObj.dataLocation = path + (current.value == 'list' ? '' : '/' + fileNameSegment);
					workingObj.finalValue = element;

					outList.push(workingObj);

				}

				return outList;

			} else {
				fileName = fileName;
				newPath = path + (current.value == 'list' ? '' : '/' + fileName);
				outObj.dataLocation = newPath;

			}
			return [outObj];
			
		} else {
			newPath = path + (current.value == 'list' ? '' : '/' + current.value);
			newQuery = newQuery + '/' + current.name + (current.value == 'list' ? '' : '/' + current.value);
			newQuery = newQuery.replace(/^\//, '');
			return digestQuery(query, newPath, newQuery, qtools.extend(status, badStatus));
		}

	}

	//INITIALIZATION ====================================

	/*
		The idea is that lightningPipe supports multiple protocols (UFF, csv?, who knows what)
		and, perhaps, subsequent versions of them as time goes by.
		
		clientProfile contains a list (hash) of potential data sources (dataSourceAvailable), one
		of which is selected based on the incoming URI. The chosen dataSource specifies the
		file path (or database access specs) where the data can be found. It also specifies the
		data dictionary definition (for UFF files, it's passThroughDefinition). THIS MAY 
		BE A PROBLEM because it turns out that file and mssql have substantially different
		dictionary needs.
		
		In addition, the server.js adds the 'api' property to the client profile. The api contains,
		mainly, the parse() routine that interprets the incoming URI into a list of name/value pairs
		that get fed to digestQuery in the fileEngine to produce the lookupControlList or to 
		the mssqlEngine to produce a SQL query.
		
		The api property also specifies the 'driver' (eg, uffFileAccessor) that is used to
		actually execute the calls to the data source. This could vary based on the version
		of the api being used. That is, while uffFileAccessor is good for UFF v1.0, it might
		not be adequate for UFF v2.0. THIS MIGHT BE BAD because it suggests that the lowest
		level access knows or cares about the api and it probably shouldn't.
		
	*/
	this.dataComponentGenerator = require(self.clientProfile.dataSource.api.fileAccessorName); //at first, it's uffFileAccessor.js

	
	
	var lookupControlList=digestQuery(self.queryInfo, '');
	
	this.dataComponentList = [];
	for (var i = 0, len = lookupControlList.length; i < len; i++) {
		var lookupControl = lookupControlList[i];


		this.dataComponentList.push({
			schema: lookupControl.finalValue,
			dataComponent:
			this.dataComponent = new this.dataComponentGenerator({
				dataSource: self.clientProfile.dataSource,
				lookupControl: lookupControl
			})
		});

	}


	this.executeQuery = function(callback) {
		if (typeof (self.badStatus) != 'undefined') {
			callback(self.badStatus);
			return;
		}
		self.parentCallback = callback;


		var list = this.dataComponentList;
		for (var i = 0, len = list.length; i < len; i++) {
			var element = list[i];
			element.dataComponent.getRawData(generateCallback(element.schema));
		}

	}

	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;





